<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Human Pose Estimation,Reproduce," />




  


  <link rel="alternate" href="/atom.xml" title="Sen Yang" type="application/atom+xml" />






<meta name="description" content="PersonLab复现过程  我打算记录整个复现的心路历程,和代码实践遇到的问题 正在写完这一行字的我, 什么代码都没写~ 所以以下的文字是一篇记叙文, 默认的叙述手法是顺序">
<meta property="og:type" content="article">
<meta property="og:title" content="Reproduce PersonLab (1)">
<meta property="og:url" content="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/index.html">
<meta property="og:site_name" content="Sen Yang">
<meta property="og:description" content="PersonLab复现过程  我打算记录整个复现的心路历程,和代码实践遇到的问题 正在写完这一行字的我, 什么代码都没写~ 所以以下的文字是一篇记叙文, 默认的叙述手法是顺序">
<meta property="og:image" content="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/output_9_2.png">
<meta property="og:image" content="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/output_9_2.png">
<meta property="article:published_time" content="2019-08-19T08:57:32.000Z">
<meta property="article:modified_time" content="2020-03-13T11:06:11.000Z">
<meta property="article:author" content="yangsenius">
<meta property="article:tag" content="Human Pose Estimation">
<meta property="article:tag" content="Reproduce">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/output_9_2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/"/>





  <title>Reproduce PersonLab (1) | Sen Yang</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sen Yang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-blogs">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Blogs
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/research/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yangsenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sen Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Reproduce PersonLab (1)</h1>
        

        <div class="post-meta">
                  

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">posted on</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T16:57:32+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="personlab复现过程">PersonLab复现过程</h1>
<blockquote>
<p>我打算记录整个复现的心路历程,和代码实践遇到的问题 正在写完这一行字的我, 什么代码都没写~ 所以以下的文字是一篇<code>记叙文</code>, 默认的叙述手法是<code>顺序</code> <a id="more"></a></p>
</blockquote>
<p>选个复现思路: - 自上而下: 从<code>train.py</code>的<code>main()</code>,逐渐构建所需要的函数以及其子函数 - 自下而上: 从每个最小的函数(如从读入数据集,预处理图像,构建标签)开始,逐渐向上封装函数</p>
<p>我倾向于后者:</p>
<p>我先想清楚了整个项目需要哪些模块, 然后创建了如下的几个空文件:</p>
<p>backbone_network.py, label_constrction.py, data_augmentation.py , data_iteration.py, loss.py, evaluate.py, greedy_decoding.py, instance_association.py, model.py , train.py</p>
<p>空文件先创建好,刺激你去复现,后面遇到问题再改</p>
<h1 id="从label_construction.py-开始">从<code>label_construction.py</code> 开始</h1>
<p>PersonLab 最精华的部分应该是<strong>如何利用COCO给定的标签信息, 利用人类的直觉和知识重新加工成几何上的监督信息</strong>, 即<code>heatmaps</code>,<code>short-range offset</code>,<code>hough_socre_maps</code>,<code>mid-range pairwise offset</code>, <code>long-range offset</code>,<code>persons_mask</code>. 所以此部分也是复现的关键步骤.</p>
<p><strong>对了</strong>, 有一点需要强调, <strong>复现前要仔细阅读论文的实验部分(Experiment)的描述.我读了一些关键的描述语言, 后面如果涉及到再详细说明</strong></p>
<p><strong>继续</strong></p>
<p><code>coco keypoint detection task</code> 数据集提供的标签格式是<code>.json</code>, 举个例子,<code>person_keypoints_val2017.josn</code>其中包含<code>info</code>和<code>annotation</code>,</p>
<ul>
<li><code>info</code>负责提供数据集中每张图像的<code>image_id</code>,<code>file_name</code>,<code>height</code>,<code>width</code></li>
<li><code>annotation</code>负责提供标注信息,其中的多个样本可能来自于同一张图像(多人问题嘛),每个样本包括如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;segmentation&quot;: [[76,46.53,省略,31.03,99,省略,46.03]],</span><br><span class="line">&quot;num_keypoints&quot;: 15,</span><br><span class="line">&quot;area&quot;: 2404.375,</span><br><span class="line">&quot;iscrowd&quot;: 0,</span><br><span class="line">&quot;keypoints&quot;: [102,50,1,0,0,0,101,46,2,0,0,0,97,46,2,82,44,2,91,49,2,97,43,2,109,66,2,112,43,2,128,73,2,71,74,2,76,79,2,94,65,2,110,81,2,84,90,2,129,99,2],&quot;image_id&quot;: 149770,</span><br><span class="line">&quot;bbox&quot;: [65,31.03,81,77.5],</span><br><span class="line">&quot;category_id&quot;: 1,</span><br><span class="line">&quot;id&quot;: 427983&#125;</span><br></pre></td></tr></table></figure> 我们的目标就是找到每张图像中所有样本,并且主要根据他们的<code>keypoints</code>,<code>segmentation</code>的坐标信息来构造上面提到的监督信号,<code>bbox</code>的坐标其实就不需要了.</li>
</ul>
<p><strong>以下论文提到的两点请注意</strong>:</p>
<p>在利用<code>segmentation</code>的时候,需要注意,作者提到了关于处理特殊情况的操作: &gt; we back-propagate across the full image, only excluding areas that contain people that have not been fully annotated with keypoints (person crowd areas and small scale person segments in the COCO dataset)</p>
<p>这意味着我们要考虑<code>iscrowd==1</code>的情况,我们在进行loss计算时,要把<code>iscrowd==1</code> 的区域mask掉.</p>
<p>此外, 在论文的<code>Imputing missing keypoint annotations</code>章节,作者说明: &gt;The standard COCO dataset does not contain keypoint annotations in the training set for the small person instances, and ignores them during model evaluation.However, it contains segmentation annotations and evaluates mask predictions for those small instances. Since training our geometric embeddings requires keypoint annotations for training, we have run the single-person pose estimator of [G-RMI] (trained on COCO data alone) in the COCO training set on image crops around the ground truth box annotations of those small person instances to impute those missing keypoint annotations.</p>
<p>因为暂时不打算用另外一个模型预测小尺寸图像的keypoints,这里我们直接忽略掉小尺寸的instance segmentation</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_coco_annotations</span><span class="params">(ann_dir,img_dir,mode=<span class="string">'val'</span>)</span>:</span></span><br><span class="line">    ann_file = os.path.join(ann_dir,<span class="string">'person_keypoints_&#123;&#125;2017.json'</span>.format(mode))</span><br><span class="line">    coco = COCO(ann_file)</span><br><span class="line">    image_id_list = coco.getImgIds()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img_id <span class="keyword">in</span> image_id_list:</span><br><span class="line"></span><br><span class="line">        anns = coco.loadAnns(coco.getAnnIds(imgIds=img_id))</span><br><span class="line">        <span class="keyword">if</span> len(anns)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        file_name = coco.imgs[img_id][<span class="string">'file_name'</span>]</span><br><span class="line">        file_path = os.path.join(img_dir,mode+<span class="string">'2017'</span>,file_name)</span><br><span class="line">        img = cv2.imread(file_path)</span><br><span class="line">        h, w, c = img.shape</span><br><span class="line"></span><br><span class="line">        <span class="comment">#crowd_mask = np.zeros((h,w),dtype='bool')</span></span><br><span class="line">        instance_masks = []</span><br><span class="line">        keypoints_skeletons = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ann <span class="keyword">in</span> anns:</span><br><span class="line">            <span class="keyword">if</span> ann[<span class="string">'area'</span>] ==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mask = coco.annToMask(ann)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ann[<span class="string">'iscrowd'</span>] ==<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># IGNORE CROWD IN PAPAER: TODO      </span></span><br><span class="line">                <span class="keyword">continue</span>       </span><br><span class="line">            <span class="keyword">if</span> ann[<span class="string">'num_keypoints'</span>] ==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># IGNORE: TODO   </span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            keypoints_skeletons.append(ann[<span class="string">'keypoints'</span>])</span><br><span class="line">            instance_masks.append(mask)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> img, keypoints_skeletons, instance_masks</span><br><span class="line">    </span><br><span class="line">ann_dir = <span class="string">'/data/dataset/coco/annotations/'</span></span><br><span class="line">img_dir = <span class="string">'/data/dataset/coco/images/'</span></span><br><span class="line"></span><br><span class="line">c = get_coco_annotations(ann_dir,img_dir)</span><br><span class="line"></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;generator object get_coco_annotations at 0x0000024759D61518&gt;</code></pre>
<p>上面是构造了一个生成器, 迭代产生(img, keypoints_skeletons, instance_masks) 这样的元组.</p>
<p>接下来要做的事,就是如何把最原始的标签重新加工编码成一个更加几何化的监督表示.</p>
<p>我们要明确一点, 论文中构造的偏移向量的表示都是在原图像尺寸的量化精度下的, 而不是神经网络直接输出的feature map的尺寸, 因为network的输出已经被降采样了, 所以不论是预测出的<code>heatmap</code>,还是<code>offsets</code>都被上采样,来还原到原图的尺寸精度上.</p>
<p>所以我们编码用来监督的表示时,需要参考原图的高度和宽度.</p>
<h2 id="根据关键点的位置构造以关键点位置为中心半径为r的圆形disk区域区域内的取值为1区域外的取值为0">根据关键点的位置构造以关键点位置为中心，半径为r的圆形disk区域，区域内的取值为1，区域外的取值为0</h2>
<p>最直接的做法是，遍历heatmap的每个位置，通过计算距离来判断是否落在某个关键点的半径范围内，但这样的时间复杂度为O(H*W) 而通过数学的直观角度，大部分的区域都是disk外的，有没有更快捷的方法，这里我采用的是：</p>
<p><code>引入高斯核的技巧，即在每个关键点的位置生成高斯分布的函数，其分布满足中心对称，那么通过设定阈值（半径处取值），大于阈值设置为1，小于阈值设置为0</code></p>
<blockquote>
<p>高斯核的技巧，避免了heatmap上所有位置的遍历，此处我用了opencv带的cv2.GaussianBlur()函数，这个实际上也是个滤波器，也包含遍历，但其复杂度为<code>O(H*W)</code>但其函数通过openc库实现。（是否需要考证一下这种方法的计算速度？毕竟滤波器遍历了整个heatmap。有没有更直接的指定位置插入高斯核的现成的函数？）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disk_mask_heatmap</span><span class="params">(one_hot_heatmap,radius)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> radius % <span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        radius = radius - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># odd number for kernel size</span></span><br><span class="line">    heatmap = cv2.GaussianBlur(one_hot_heatmap, ksize= (radius,radius), sigmaX=<span class="number">1</span>, sigmaY=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_threshold_value</span><span class="params">(ksize)</span>:</span></span><br><span class="line">        <span class="comment"># In order to get a circle(disk ) mask, </span></span><br><span class="line">        <span class="comment"># we need to find a threshold value `t` in Gaussian kernel size, v=1 if v&gt;t else 0 </span></span><br><span class="line">        <span class="comment"># sample value in position: circle center + radius//2  </span></span><br><span class="line">        <span class="comment"># to get a approximate disk of radius</span></span><br><span class="line">        square = np.zeros(shape=(ksize[<span class="number">0</span>]*<span class="number">2</span>,ksize[<span class="number">1</span>]*<span class="number">2</span>))</span><br><span class="line">        center = square.shape[<span class="number">0</span>]//<span class="number">2</span>, square.shape[<span class="number">1</span>]//<span class="number">2</span></span><br><span class="line">        square[center[<span class="number">0</span>],center[<span class="number">1</span>]]=<span class="number">1</span></span><br><span class="line">        gaussian = cv2.GaussianBlur(square, ksize, sigmaX=<span class="number">1</span>, sigmaY=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        circle_border_value = gaussian[center[<span class="number">0</span>],center[<span class="number">1</span>]+ksize[<span class="number">1</span>]//<span class="number">2</span>] <span class="comment"># border of circle</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> circle_border_value</span><br><span class="line"></span><br><span class="line">    threshold = get_threshold_value(ksize=(radius,radius))</span><br><span class="line">    heatmap = (heatmap &gt;= threshold)</span><br><span class="line">    <span class="keyword">return</span> heatmap</span><br></pre></td></tr></table></figure>
<p>上述方法可以解决了生成disk的难题，但是接下考虑构造short-range offset时，必须找到在关键点周围半径内的位置计算偏移。这种功能要求代码，必须给定一个关键点位置，就可以获得其周围对应的位置。这个需求也就是：<code>在产生指定圆的时候，同时记录其圆内所有像素的位置和像素相对于圆心的偏移。</code></p>
<p>但是上面的代码不是逐个处理关键点的方法，而是一次性生成的，所以不能够实现上面的需求</p>
<p>获取heatmap上位置索引的技巧，比如，给定一个HxW大小的heatmaps</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">H,W =<span class="number">3</span>,<span class="number">3</span> </span><br><span class="line">map_shape = (H, W) </span><br><span class="line">idx = np.rollaxis(np.indices(map_shape[::<span class="number">-1</span>]), <span class="number">0</span>, <span class="number">3</span>).transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)) </span><br><span class="line">print(idx.shape)</span><br><span class="line">print(idx)</span><br><span class="line">print(idx[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(3, 3, 2)
[[[0 0]
  [1 0]
  [2 0]]

 [[0 1]
  [1 1]
  [2 1]]

 [[0 2]
  [1 2]
  [2 2]]]
-1</code></pre>
<p>这就可以得到了heatmap每个位置的地址索引. 继续考虑如何构造disk区域。 ## 获取每个关键点影响周围的disk区域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_keypoint_discs</span><span class="params">(all_keypoints,map_shape,K=<span class="number">17</span>,radius=<span class="number">4</span>)</span>:</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    idx = np.rollaxis(np.indices(map_shape[::<span class="number">-1</span>]), <span class="number">0</span>, <span class="number">3</span>).transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    discs = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(all_keypoints))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(K):</span><br><span class="line">        </span><br><span class="line">        centers = [keypoints[i,:<span class="number">2</span>] <span class="keyword">for</span> keypoints <span class="keyword">in</span> all_keypoints <span class="keyword">if</span> keypoints[i,<span class="number">2</span>] &gt; <span class="number">0</span>]</span><br><span class="line">        dists = np.zeros(map_shape+(len(centers),))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, center <span class="keyword">in</span> enumerate(centers):</span><br><span class="line">            dists[:,:,k] = np.sqrt(np.square(center-idx).sum(axis=<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">if</span> len(centers) &gt; <span class="number">0</span>:</span><br><span class="line">            inst_id = dists.argmin(axis=<span class="number">-1</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(all_keypoints)):</span><br><span class="line">            <span class="keyword">if</span> all_keypoints[j][i,<span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                discs[j].append(np.logical_and(inst_id==count, dists[:,:,count]&lt;=radius))</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                discs[j].append(np.array([]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># discs.shape N*K*[indices of the specified keypoint]</span></span><br><span class="line">    discs = np.array(discs)</span><br><span class="line">    <span class="keyword">return</span> discs</span><br></pre></td></tr></table></figure>
<p>返回的discs，包含K个heatmap，其中每个heatmap对应一种类型的人体关键点的所有人体的位置，每个位置的周围disk内的所有像素的位置的索引。进而达到了功能的需求。</p>
<p>进而我们可以设计这样的函数,根据所有人体的所有关键点的位置集合,</p>
<ul>
<li>获取每个关键点位置周围的disk区域,进行赋值,得到heatmaps</li>
<li>获取每个关键点位置周围的disk区域内每个像素的位置索引,与中心位置在x,y方向上作差,得到short offsets</li>
<li>获取起始关键点位置周围的disk区域内每个像素的位置索引,用终点关键点的位置于这些像素位置的索引作差，得到mid-range offsets</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_keypoint_discs</span><span class="params">(all_keypoints,map_shape,kpts_num=<span class="number">17</span>,radius=<span class="number">4</span>)</span>:</span></span><br><span class="line">	print(all_keypoints)</span><br><span class="line"></span><br><span class="line">	idx = np.rollaxis(np.indices(map_shape[::<span class="number">-1</span>]), <span class="number">0</span>, <span class="number">3</span>).transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">	discs = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(all_keypoints))]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(kpts_num):</span><br><span class="line"></span><br><span class="line">		centers = [keypoints[i,:<span class="number">2</span>] <span class="keyword">for</span> keypoints <span class="keyword">in</span> all_keypoints <span class="keyword">if</span> keypoints[i,<span class="number">2</span>] &gt; <span class="number">0</span>]</span><br><span class="line">		dists = np.zeros(map_shape+(len(centers),))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> k, center <span class="keyword">in</span> enumerate(centers):</span><br><span class="line">			dists[:,:,k] = np.sqrt(np.square(center-idx).sum(axis=<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">if</span> len(centers) &gt; <span class="number">0</span>:</span><br><span class="line">			inst_id = dists.argmin(axis=<span class="number">-1</span>)</span><br><span class="line">		count = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(all_keypoints)):</span><br><span class="line">			<span class="keyword">if</span> all_keypoints[j][i,<span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">				discs[j].append(np.logical_and(inst_id==count, dists[:,:,count]&lt;=radius))</span><br><span class="line">				count +=<span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				discs[j].append(np.array([]))</span><br><span class="line"></span><br><span class="line">	<span class="comment"># discs.shape N*kpts_num*[indices of the specified keypoint]</span></span><br><span class="line">	discs = np.array(discs)</span><br><span class="line">	<span class="keyword">return</span> discs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kpts_maps</span><span class="params">(keypoints_skeletons,discs,map_shape,kpts_num=<span class="number">17</span>)</span>:</span></span><br><span class="line">	<span class="comment"># discs.shape N*kpts_num*[indices of the specified keypoint]</span></span><br><span class="line">	kpts_maps = np.zeros(map_shape+(kpts_num,))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(discs)):</span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> range(kpts_num):</span><br><span class="line">			<span class="comment">#print(keypoints_skeletons[n,k,2])</span></span><br><span class="line">			<span class="keyword">if</span> keypoints_skeletons[n,k,<span class="number">2</span>] &gt; <span class="number">0.</span>:</span><br><span class="line"></span><br><span class="line">				disk_indices = discs[n][k]</span><br><span class="line">				kpts_maps[disk_indices,k] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kpts_maps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_offsets</span><span class="params">(keypoints_skeletons,discs,map_shape,kpts_num=<span class="number">17</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># discs.shape N*kpts_num*[indices of the specified keypoint]</span></span><br><span class="line">	<span class="comment">#disk_mask_map = np.zeros(shape=map_shape+(kpts_num,),dtype='bool')</span></span><br><span class="line">	short_offsets = np.zeros(map_shape+(kpts_num,<span class="number">2</span>,))</span><br><span class="line">	<span class="comment">#map_shape = (H, W)</span></span><br><span class="line">	<span class="comment"># [H,W,2]  for each pixel's (x,y) position index</span></span><br><span class="line">	pixels_indices = np.rollaxis(np.indices(map_shape[::<span class="number">-1</span>]), <span class="number">0</span>, <span class="number">3</span>).transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(discs)):</span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> range(kpts_num):</span><br><span class="line">			<span class="keyword">if</span> keypoints_skeletons[n,k,<span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">				disk_indices = discs[n][k]</span><br><span class="line"></span><br><span class="line">				kpt_x = keypoints_skeletons[n][k,<span class="number">0</span>]</span><br><span class="line">				kpt_y = keypoints_skeletons[n][k,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">				short_offsets[disk_indices,k,<span class="number">0</span>] = pixels_indices[disk_indices,<span class="number">0</span>] - kpt_x</span><br><span class="line">				short_offsets[disk_indices,k,<span class="number">1</span>] = pixels_indices[disk_indices,<span class="number">1</span>] - kpt_y</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> short_offsets</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid_range_offsets</span><span class="params">(pair_wise_kpts,keypoints_skeletons,discs,map_shape,kpts_num=<span class="number">17</span>)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	pair_wisd_kpts: for COCO, edges of tree structures of body is `kpts_num-1`</span></span><br><span class="line"><span class="string">	such as [[kpt_shoulder_r,kpt_ankle_r],[kpt_shoulder_r,nose],..,[]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	discs.shape Number of people*kpts_num*[disk indices of the specified keypoint]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return [H,W,2*(kpts_num-1),2]</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	directed_edges = []</span><br><span class="line">	<span class="keyword">for</span> edge <span class="keyword">in</span> pair_wise_kpts:</span><br><span class="line">		directed_edges.append(edge)</span><br><span class="line">		<span class="comment">#directed_edges.append(edge[::-1])</span></span><br><span class="line"></span><br><span class="line">	mid_offsets = np.zeros(map_shape+(len(directed_edges),<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">	<span class="comment"># [H,W,2]  for each pixel's (x,y) position index</span></span><br><span class="line">	pixels_indices = np.rollaxis(np.indices(map_shape[::<span class="number">-1</span>]), <span class="number">0</span>, <span class="number">3</span>).transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(discs)):</span><br><span class="line">		<span class="keyword">for</span> edge_id, direct_edge <span class="keyword">in</span> enumerate(directed_edges):</span><br><span class="line">			begin_kpt_id, end_kpt_id = direct_edge</span><br><span class="line">			begin_kpt = keypoints_skeletons[n][begin_kpt_id]</span><br><span class="line">			end_kpt = keypoints_skeletons[n][end_kpt_id]</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> begin_kpt[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> end_kpt[<span class="number">2</span>] &gt;<span class="number">0</span>:</span><br><span class="line">				disk_indices = discs[n][begin_kpt_id]</span><br><span class="line">				<span class="comment">#print(end_kpt[0],pixels_indices[disk_indices])</span></span><br><span class="line">				mid_offsets[disk_indices,edge_id,<span class="number">0</span>] = end_kpt[<span class="number">0</span>] - pixels_indices[disk_indices,<span class="number">0</span>]</span><br><span class="line">				mid_offsets[disk_indices,edge_id,<span class="number">1</span>] = end_kpt[<span class="number">1</span>] - pixels_indices[disk_indices,<span class="number">1</span>]</span><br><span class="line">				<span class="comment">#print(mid_offsets[disk_indices,edge_id])</span></span><br><span class="line">	<span class="keyword">return</span> mid_offsets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">	<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">	<span class="comment">#keypoints_skeletons1 = np.array([[[28,28,1],[61,61,1],[155,155,1]],[[20,20,1],[55,55,1],[6,6,1]]])</span></span><br><span class="line">	keypoints_skeletons = np.array(</span><br><span class="line">		[</span><br><span class="line">		[[<span class="number">28</span>,<span class="number">228</span>,<span class="number">1</span>],[<span class="number">161</span>,<span class="number">361</span>,<span class="number">1</span>],[<span class="number">55</span>,<span class="number">455</span>,<span class="number">1</span>],[<span class="number">64</span>,<span class="number">54</span>,<span class="number">1</span>],[<span class="number">368</span>,<span class="number">550</span>,<span class="number">1</span>]],</span><br><span class="line">		<span class="comment">#[[20,120,1],[55,55,1],[6,6,1]]</span></span><br><span class="line">		]</span><br><span class="line">		)</span><br><span class="line">		</span><br><span class="line">	pair_wise_kpts = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">	print(<span class="string">"keypoints coordiantes:\n"</span>,keypoints_skeletons,<span class="string">"\npair wise keypoints:\n"</span>,pair_wise_kpts)</span><br><span class="line"></span><br><span class="line">	map_shape = (<span class="number">600</span>,<span class="number">600</span>)</span><br><span class="line">	kpts_num = <span class="number">5</span></span><br><span class="line">	radius = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">	discs = get_keypoint_discs(keypoints_skeletons,map_shape,kpts_num,radius)</span><br><span class="line">	</span><br><span class="line">	kpts_heatmaps = kpts_maps(keypoints_skeletons,discs,map_shape,kpts_num)</span><br><span class="line">	visual_kpts_heatmaps = np.amax(kpts_heatmaps,axis=<span class="number">-1</span>)</span><br><span class="line">	short = short_offsets(keypoints_skeletons,discs,map_shape,kpts_num)</span><br><span class="line"></span><br><span class="line">	offsets_magnitude = np.sqrt(np.square(short).sum(axis=<span class="number">-1</span>))</span><br><span class="line">	visual_offsets_magnitude=np.max(offsets_magnitude,axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># show mid_range_offset</span></span><br><span class="line">	mid_offsets = mid_range_offsets(pair_wise_kpts,</span><br><span class="line">									keypoints_skeletons,</span><br><span class="line">									discs,</span><br><span class="line">									map_shape,</span><br><span class="line">									kpts_num)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">#mid_offsets_edge = mid_offsets[:,:,0::2,:] # directed edges</span></span><br><span class="line">	mid_offsets_edge = mid_offsets 			  <span class="comment"># undirected edges</span></span><br><span class="line"></span><br><span class="line">	mid_offsets_edge = mid_offsets_edge.astype(<span class="string">'int'</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># (h,w,2)</span></span><br><span class="line">	pixels_indices = np.rollaxis(np.indices(map_shape[::<span class="number">-1</span>]), <span class="number">0</span>, <span class="number">3</span>).transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># canvs</span></span><br><span class="line">	background = np.zeros(map_shape+(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(discs)):</span><br><span class="line">		<span class="keyword">for</span> edge_id, edge <span class="keyword">in</span> enumerate(pair_wise_kpts):</span><br><span class="line">			<span class="keyword">if</span> keypoints_skeletons[n,edge[<span class="number">0</span>],<span class="number">2</span>]&gt;<span class="number">0</span> <span class="keyword">and</span> keypoints_skeletons[n,edge[<span class="number">1</span>],<span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">				begin_disk_indices = discs[n][edge[<span class="number">0</span>]]</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (x,y) <span class="keyword">in</span> pixels_indices[begin_disk_indices]:</span><br><span class="line">					<span class="comment"># sparse disk setting for better visualization</span></span><br><span class="line">					<span class="keyword">if</span> x %<span class="number">8</span>==<span class="number">0</span> <span class="keyword">and</span> y%<span class="number">8</span> ==<span class="number">0</span>:</span><br><span class="line">						<span class="comment">#continue</span></span><br><span class="line">						begin_kpt = (x,y)</span><br><span class="line">                        <span class="comment"># note: mid_offsets_edge[y,x,edge_id,0] not: mid_offsets_edge[x,y,edge_id,0]</span></span><br><span class="line">						end_kpt = (x + mid_offsets_edge[y,x,edge_id,<span class="number">0</span>], y + mid_offsets_edge[y,x,edge[<span class="number">0</span>],<span class="number">1</span>])</span><br><span class="line">						</span><br><span class="line">						cv2.line(background,begin_kpt,end_kpt,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),thickness=<span class="number">2</span>)</span><br><span class="line">                        </span><br><span class="line">	fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line">	fig.add_subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">	plt.imshow(visual_kpts_heatmaps )</span><br><span class="line">	plt.title(<span class="string">"heatmaps of keypoints"</span>)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	fig.add_subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">	plt.imshow(visual_offsets_magnitude)</span><br><span class="line">	plt.title(<span class="string">"the magnitude of short offsets"</span>)</span><br><span class="line">	</span><br><span class="line">	fig.add_subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">	plt.imshow(background)</span><br><span class="line">	plt.title(<span class="string">"mid_range_offsets of keypoints"</span>)</span><br><span class="line">	</span><br><span class="line">	plt.savefig(<span class="string">'visualization.png'</span>)</span><br><span class="line">	plt.show()</span><br><span class="line"></span><br><span class="line">visualize()</span><br></pre></td></tr></table></figure>
<pre><code>keypoints coordiantes:
 [[[ 28 228   1]
  [161 361   1]
  [ 55 455   1]
  [ 64  54   1]
  [368 550   1]]] 
pair wise keypoints:
 [[0, 1], [1, 2], [2, 4], [3, 4]]
[[[ 28 228   1]
  [161 361   1]
  [ 55 455   1]
  [ 64  54   1]
  [368 550   1]]]


Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).</code></pre>
<p><img src="/2019/08/19/Reproduce-PersonLab/output_9_2.png" alt="visualization"> <!-- <img src="/2019/08/19/Reproduce-PersonLab/output_9_2.png" class="" title="[visualization]"> --&gt;</p>
<p>经过了很多的BUG和debug的过程，终于可视化出了自己期望的效果</p>
<p>会发现，我们可以得到了和论文Ｇ－ＲＭＩ和 PersonLab 中一样的disk的效果： short-offsets指向圆心，其模长的分布为：中心为０，向外靠近ｄｉｓｋ边缘时增大，边缘最大，然后陡然减为0 （是不是可以考虑优化一下？） mid-offsets: 从起点关键点的disk内的像素点指向，终点的关键点位置的向量场</p>
<p>待续 ...</p>
--></p>
      
    </div>
    
    
    

    

    

    
      <div>
        
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Author：</strong>
    yangsenius
  </li>
  <li class="post-copyright-link">
    <strong>Link：</strong>
    <a href="http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/" title="Reproduce PersonLab (1)">http://senyang-ml.github.io/2019/08/19/Reproduce-PersonLab/</a>
  </li>
  <li class="post-copyright-license">
    <strong>License： </strong>
    Unless otherwise stated,  all blogs use the <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> protocol, please indicate the source
  </li>
</ul>


      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Human-Pose-Estimation/" rel="tag"># Human Pose Estimation</a>
          
            <a href="/tags/Reproduce/" rel="tag"># Reproduce</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/21/Chelsea-Finn/" rel="next" title="Chelsea Finn">
                <i class="fa fa-chevron-left"></i> Chelsea Finn
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/26/Pose-Neural-Fabrics-Search/" rel="prev" title="Pose Neural Fabrics Search">
                Pose Neural Fabrics Search <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Toc
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yangsenius</p>
              <p class="site-description motion-element" itemprop="description">Talk is not cheap</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:yangsenius@seu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#personlab复现过程"><span class="nav-number">1.</span> <span class="nav-text">PersonLab复现过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从label_construction.py-开始"><span class="nav-number">2.</span> <span class="nav-text">从label_construction.py 开始</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#根据关键点的位置构造以关键点位置为中心半径为r的圆形disk区域区域内的取值为1区域外的取值为0"><span class="nav-number">2.1.</span> <span class="nav-text">根据关键点的位置构造以关键点位置为中心，半径为r的圆形disk区域，区域内的取值为1，区域外的取值为0</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yangsenius</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: ,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


      
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
